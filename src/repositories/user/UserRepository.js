import { RoleModel, UserModel } from '../../models/index.js';
import jwt from 'jsonwebtoken';
import crypto from 'node:crypto';

import {
  emailVerificationMailgenContent,
  sendEmail,
} from '../../utils/mail.js';
import { ApiError } from '../../utils/ApiError.js';
import { mongoUtils } from '../../lib/mongo.js';

class UserRepository {
  // Create a new user
  async create(userData, req) {
    // Find the role by name
    const role = await RoleModel.findOne({ name: userData.role });
    if (!role) {
      return res.status(400).json({ message: 'Invalid role name' });
    }

    // Create a new user
    const user = mongoUtils.createDocument(UserModel, {
      ...userData,
      isEmailVerified: false,
      role: role._id, // Reference the role ID
    });

    /**
     * unHashedToken: unHashed token is something we will send to the user's mail
     * hashedToken: we will keep record of hashedToken to validate the unHashedToken in verify email controller
     * tokenExpiry: Expiry to be checked before validating the incoming token
     */
    const { unHashedToken, hashedToken, tokenExpiry } =
      user.generateTemporaryToken();

    /**
     * assign hashedToken and tokenExpiry in DB till user clicks on email verification link
     * The email verification is handled by {@link verifyEmail}
     */
    user.emailVerificationToken = hashedToken;
    user.emailVerificationExpiry = tokenExpiry;
    await sendEmail({
      email: user?.email,
      subject: 'Please verify your email',
      mailgenContent: emailVerificationMailgenContent(
        user.username,
        `${req.protocol}://${req.get(
          'host',
        )}/api/v1/user/verify-email/${unHashedToken}`,
      ),
    });
    return await user.save();
  }

  // Read all users
  async findAll() {
    return await UserModel.find().select(
      '-password -refreshToken -emailVerificationToken -emailVerificationExpiry -__v -forgotPasswordExpiry -forgotPasswordToken',
    );
  }

  // Find user by ID
  async findById(id) {
    return await UserModel.findById(id);
  }

  // Find user by email and username
  async getUser(email, username) {
    return await UserModel.findOne({
      $or: [{ email: email }, { username: username }],
    });
  }
  // check user Password Correct or not
  async generateAccessAndRefreshTokens(userId) {
    try {
      const user = await UserModel.findById(userId);

      const accessToken = user.generateAccessToken();
      const refreshToken = user.generateRefreshToken();

      // attach refresh token to the user document to avoid refreshing the access token with multiple refresh tokens
      user.refreshToken = refreshToken;

      await user.save({ validateBeforeSave: false });
      return { accessToken, refreshToken };
    } catch (error) {
      throw new ApiError(
        500,
        'Something went wrong while generating the access token',
        error.message,
      );
    }
  }
  // get LoggedIn User Without Password
  async getUserDetailsWithoutPassword(userId) {
    return await UserModel.findById(userId).select(
      '-password -refreshToken -emailVerificationToken -emailVerificationExpiry -__v -forgotPasswordExpiry -forgotPasswordToken',
    );
  }

  // Update user by ID
  async update(id, updateData) {
    const user = UserModel.findByIdAndUpdate(id, updateData, { new: true });
    return await user.select(
      '-password -refreshToken -emailVerificationToken -emailVerificationExpiry -__v -forgotPasswordExpiry -forgotPasswordToken',
    );
  }
  // Verify JWT Token
  async verifyJwtToken(incomingRefreshToken) {
    return jwt.verify(incomingRefreshToken, process.env.REFRESH_TOKEN_SECRET);
  }
  // Verify Email Token
  async verifyEmailToken(incomingEmailHashedToken) {
    // generate a hash from the token that we are receiving from the user
    let hashedToken = crypto
      .createHash('sha256')
      .update(incomingEmailHashedToken)
      .digest('hex');

    // While registering the user, same time when we are sending the verification mail
    // we have saved a hashed value of the original email verification token in the db
    // We will try to find user with the hashed token generated by received token
    // If we find the user another check is if token expiry of that token is greater than current time if not that means it is expired
    const user = await UserModel.findOne({
      emailVerificationToken: hashedToken,
      emailVerificationExpiry: { $gt: Date.now() },
    });

    if (!user) {
      throw new ApiError(489, 'Token is invalid or expired');
    }
    // If we found the user that means the token is valid
    // Now we can remove the associated email token and expiry date as we no  longer need them
    user.emailVerificationToken = undefined;
    user.emailVerificationExpiry = undefined;
    // Turn the email verified flag to `true`
    user.isEmailVerified = true;
    await user.save({ validateBeforeSave: false });
    return user;
  }

  // Delete user by ID
  async delete(id) {
    return await UserModel.findByIdAndDelete(id);
  }

  async verifyPasswordResetTokenAndUpdate(
    incomingPaaswordHashedToken,
    newPassword,
  ) {
    // Create a hash of the incoming reset token

    let hashedToken = crypto
      .createHash('sha256')
      .update(incomingPaaswordHashedToken)
      .digest('hex');

    // See if user with hash similar to resetToken exists
    // If yes then check if token expiry is greater than current date

    const user = await UserModel.findOne({
      forgotPasswordToken: hashedToken,
      forgotPasswordExpiry: { $gt: Date.now() },
    });

    // if everything is ok and token id valid
    // reset the forgot password token and expiry
    user.forgotPasswordToken = undefined;
    user.forgotPasswordExpiry = undefined;

    // Set the provided password as the new password
    user.password = newPassword;
    await user.save({ validateBeforeSave: false });
    return user;
  }
}

export default new UserRepository();
